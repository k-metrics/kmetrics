---
title: "R Basics, zero"
output:
  learnr::tutorial:
    df_print: "paged"
    highlight: textmate
    md_extensions: -ascii_identifiers
runtime: shiny_prerendered
description: > 
  **Japanese** Tutorial, 2018年度データ分析勉強会特別回で用いた資料の一部を再整理し対話型チュートリアル形式にしました。
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, error = TRUE)

htmltools::tagList(rmarkdown::html_dependency_font_awesome())

require(learnr)
require(tidyverse)

if (getRversion() >= "3.6.0") {
  RNGversion("3.5.3")     # R >= 3.6.0の場合のみ（前方互換性確保のため）
}
```

## はじめに
本チュートリアルは、2018年度データ分析勉強会特別回で用いた資料をチュートリアル形式にまとめなおしたものです。とにかくやってみようというスタンスで手を動かしてコードを書くことを前提に構成しています。  
なお、本チュートリアルは『Base R Cheetsheet』（ [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)）のコードの一部を参考にしています。  

　  

### チュートリアルの使い方 {.tabset}
各演習では以下のようなチュートリアルエリアが表示されます。解答コードを記述し`［Run Code］`ボタンをクリックすると実行結果が表示されると共に実行したことが記録されます。解答が分からない場合は`［Hint］`ボタンをクリックするとヒントが表示されます。ヒントに記載されているコードをコピーするには`［Copy to Clipboard］`ボタンをクリックしてください。解答をやり直す場合には`［Satrt Over］`ボタンをクリックしてから解答を記述し再実行します。  
左側のメニュー最下部にある`［Start Over］`をクリックすると全ての学習記録がクリアされます。

#### 設問
`iris`データセットを表示してください。演習を実行したら［解説］タブをクリックします。
```{r tutorial-example, exercise=TRUE, exercise.cap="演習タイトル"}
# Write R code here
```

```{r tutorial-example-hint, exercise=FALSE}
# Hint
iris
```
---

#### 解説
解説がある場合は、このようなタブ形式で表示します。タブが表示されていない演習には解説がありません。
```{r}
head(iris)
```


---

では、［Next Topic］ボタンをクリックしてチュートリアルを始めましょう。



## Rの特徴
Rの一番の特徴と言えるのが、一度に複数の値を同時に計算することが可能な点ところです。  


### 【演習】加算 {.tabset}

#### 設問
以下の加算を実行してください。  
```{r basic-operation-plus, exercise=TRUE}
c(1, 2, 3, 4, 5) + c(1, 2, 1, 2, 1)
```
---

#### 解説
Rでの演算は基本的に等長であることが条件です。不等長の演算を行うと短い側は、値を先頭から再利用して長さを合わせます。例えば、
```{r}
c(1, 2, 3, 4, 5) + c(1, 2, 1)
```
は先頭から二つ（`1, 2`）を再利用しますので、以下と同様の結果になります。
```{r}
c(1, 2, 3, 4, 5) + c(1, 2, 1, 1, 2)
```
---


### 【演習】乗算 
このように複数の値を演算するのにループ処理を必要としませんので、非常に簡単かつ高速に処理することが可能です。では、以下の乗算を実行してください。
```{r basic-operation-multi, exercise=TRUE}
c(1, 2, 3, 4, 5) * c(1, 2, 1, 2, 1)
```
---


### 【演習】減算
次に上記の加算と乗算で利用した値（`c(1, 2, 3, 4, 5)`と`c(1, 2, 1, 2, 1)`）を使って除算を実行してください。 
```{r basic-operation-minus, exercise=TRUE}

```

```{r basic-operation-minus-hint, exercise=FALSE}
c(1, 2, 3, 4, 5) - c(1, 2, 1, 2, 1)
```
---

### 【演習】除算
同様に除算を実行してください。
```{r basic-operation-div, exercise=TRUE}

```

```{r basic-operation-div-hint, exercise=FALSE}
c(1, 2, 3, 4, 5) / c(1, 2, 1, 2, 1)
```
---



## ベクトル型
前トピックの`c`関数はベクトル型（変数）を作成するための関数です。ベクトル型（変数）とは一次元配列の構造を持った型（変数）をいいます。つまり、ベクトル型（変数）は一つの変数の中に複数の値を持てる型で、Rが扱う全ての変数型の根幹をなします。
`c`関数の返り値を任意の変数名に代入することで変数（オブジェクト）が作成できます。では、実際にベクトル型変数の作成・参照方法を学んでいきます。


### 【演習】変数の作成 {.tabset}

#### 設問
以下を実行して変数`a`と変数`b`を作成してください。  
```{r variable-basics-ab, exercise=TRUE}
a <- c(1, 2, 3, 4, 5)
b <- c(1, 2, 1, 2, 1)
```
---

#### 解説
変数名は英字から始まる任意の文字列を使うことができます。ただし、予約語（Reserved Words）と言われる特別な意味を持った名前は変数名として使えません。  
代入には代入演算子（`<-`）を用います。代入しただけではエラーでもない限り何も表示されません。`=`でも代入可能ですが代入での`=`の利用は推奨されていません。
```{r}
a <- c(1, 2, 3, 4, 5)
b = c(1, 2, 1, 2, 1)   # 推奨されていない記述方法
```
---

```{r variable-basics-create, echo=FALSE}
a <- c(1, 2, 3, 4, 5)
b <- c(1, 2, 1, 2, 1)
```


### 【演習】変数の参照
代入結果を参照（表示）するには変数名のみを記述して実行します。作成した変数`a`と`b`を参照するコードを記述して実行してください。  
```{r variable-basics-ref, exercise=TRUE, exercise.setup="variable-basics-create"}

```

```{r variable-basics-ref-hint, exercise=FALSE}
a
b
```
---


### 部分的な参照
上記の変数名を実行する方法は変数全体を参照する方法です。では、変数を部分的に参照するにはどのようにしたら良いかを以下の変数`x`を用いて学びます。
```{r}
x <- c(1:10)
x
```

```{r variable-ref-x, echo=FALSE}
x <- c(1:10)
```


### 【演習】基本的な参照 {.tabset}
変数`x`の$n$番目の値を参照するには参照演算子（`[]`）を用いて、`x[n]`と番号（インデックス`n`）で指定することにより参照します。

#### 設問
変数`x`の4番目の値を参照してください。  
```{r variable-ref-by-position, exercise=TRUE, exercise.setup="variable-ref-x"}
x[4]
```
---

#### 解説
ベクトル内の位置を示す番号（インデックス）は$1$から始まります。ベクトル型を参照した際に左側に表示される`[1]`や`[26]`という数字は最初に表示されている値のインデックス値です。
```{r}
c(0:99)
```
---


### 【演習】マイナスを用いた参照 {.tabset}
では、インデックスに`-`記号を指定するとどのような参照になるでしょうか？ 

#### 設問
以下のコードを実行して確認してください。
```{r variable-ref-by-minus-position, exercise=TRUE, exercise.setup="variable-ref-x"}
x[-4]
```
---

#### 解説
Rではインデックスにマイナスの値を指定するとそのインデックスが示す値を**取り除き**ます。他言語で見られる後方からの参照とは異なります。
```{r}
x[-1]
x[-10]
```
---

#### Tips
最後尾からの参照を行いたい場合は`tail`関数を用いてください。引数`n`で参照する個数が指定できます。`n`を省略した場合のデフォルト値は$6$です。
```{r}
tail(x, n = 6L)
```
---


### 【演習】範囲指定による参照 {.tabset}
連続した任意の範囲の値をするには`:`演算子を用います。`:`演算子は整数の等差数列を作成する演算子です。

#### 設問
以下を実行して確認してください。  
```{r variable-ref-by-range, exercise=TRUE, exercise.cap="範囲参照", exercise.setup="variable-ref-x"}
x[2:4]
```
---

#### 解説
`:`演算子の返り値はベクトル型になりますので`c`関数の省略が可能です。以下は全て等価になることを憶えてください。
```{r}
2:4
c(2:4)
c(2, 3, 4)
```
---

#### Tips
変数`x`の範囲（`r length(x)`）外まで指定した場合は`NA`という値がないことを意味する値が返ります。
```{r}
x[9:12]
```
---


### 【演習】マイナス範囲での参照 {.tabset}

#### 設問
`:`演算子にマイナスを指定するとどうなるか以下を実行して確認してください。  
```{r variable-ref-by-minus-range, exercise=TRUE, exercise.cap="マイナス範囲参照", exercise.setup="variable-ref-x"}
x[-(2:4)]
```
---

#### 解説
マイナス値による参照と範囲指定による参照を組み合わせた考え方です。以下は全て等価になります。
```{r}
-(2:4)
c(-(2:4))
-c(2:4)
c(-2, -3, -4)
-c(2, 3, 4)
```
---

#### Tips
マイナス値のインデックスとプラス値のインデックスを組み合わせて指定することはできません。
```{r}
x[c(-2, 4)]
```
変数`x`の2番目の値（$2$）を外してから変数`x`の4番目の値（$4$）を参照する場合は以下のようにします。
```{r}
z <- x[-2]
z[3]
```
---


### 【演習】複数位置の参照 {.tabset}
連続したインデックスだけでなく離散したインデックスを指定することも可能です。

#### 設問
変数`x`の1番目と5番目の値を参照するコードを記述・実行してください。  
```{r variable-ref-exec-1, exercise=TRUE, exercise.cap="任意の箇所の参照", exercise.setup="variable-ref-x"}

```

```{r variable-ref-exec-1-solution, exercise=FALSE}
x[c(1, 5)]
```
---

#### 解説
範囲指定では連続したインデックスを指定していましたが、任意の複数位置を参照する場合は、任意のインデックスを指定するだけです。連続であろうと離散であろうと展開すれば同じベクトル型のインデックスです。
```{r}
c(2:4)
c(2, 4, 6)
```
---

#### Tips
範囲外のインデックスを指定した場合は範囲指定の場合と同様に`NA`という値がないことを意味する値が返ります。
```{r}
x[c(1, 3, 11)]
```
---


### 【演習】値の大きさによる参照 {.tabset}

#### 設問
変数`x`の値が5未満のものを参照するコードを記述・実行してください。  
```{r variable-ref-exec-2, exercise=TRUE, exercise.cap="任意の箇所の参照", exercise.setup="variable-ref-x"}

```

```{r variable-ref-exec-2-solution, exercise=FALSE}
x[x < 5]
```
---

#### 解説
変数`x`の値が$5$未満であるか否かは下式により判定することができ、その返り値は長さ$`r length(x)`$
の論理型（Boolean）ベクトルになります。
```{r}
x < 5
```
つまり、`x[x < 5]`という参照は全範囲を論理型で参照した場合と等価です。
```{r}
x[c(TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)]
```
---

#### Tips
奇数番目や偶数番目の値だけを参照したい場合には「加算」演習の解説にあった不等長のベクトル演算とこの論理型ベクトルでの指定を組み合わせれば簡単に参照することができます。
```{r}
x[c(TRUE, FALSE)]    # 奇数番目を取り出す
x[c(FALSE, TRUE)]    # 偶数番目を取り出す
```
---


## マトリクス型
マトリクス型（行列型）はベクトル型を拡張して$n$行$m$列の二次元のベクトルを扱えるようにした型です。ソフトウェアメトリクス分析ではマトリクス型変数自体を扱うことはほぼないと思われますが、Rの様々な関数がマトリクス型を引数や返り値で使っていますので、基本的なところだけ憶えてください。  
　  
マトリクス型はベクトル型から作成しますので、元となる変数`x`を以下のように定義しておきます。
```{r}
x <- c(1:9)
x
```

```{r matrix-ref-x, echo=FALSE}
x <- c(1:9)
```

　  

### 【演習】マトリクス型の作成 {.tabset}
マトリクス型を作成するには`matrix`関数を用いて、ベクトル型をマトリクス型に変換することで作成します。  

#### 設問
以下のコードを実行してベクトル型変数`x`から3行3列のマトリクス型変数`m`を作成してください。  
```{r matrix-m, exercise=TRUE, exercise.cap="マトリクス型変数の作成", exercise.setup="matrix-ref-x"}
m <- matrix(x, nrow = 3, ncol = 3)
m
```

```{r matrix-ref-m, echo=FALSE}
m <- matrix(x, nrow = 3, ncol = 3)
```
---

#### 解説
`matrix`関数はデフォルトで列方法から値を割り当てます。
```{r}
matrix(x, nrow = 3, ncol = 3)
```
行方向で指定したい場合は`byrow`オプションを`TRUE`に指定してください。
```{r}
matrix(x, nrow = 3, ncol = 3, byrow = TRUE)
```
---

#### Tips
列数の指定を省略することも可能です。
```{r}
matrix(x, nrow = 3)
```
同様に行数の指定を省略することも可能ですが、慣れないうちは指定の省略をおすゝめしません。
```{r}
matrix(x, ncol = 3)
```
---


### 【演習】不一致指定 {.tabset}
元データのベクトル長より大きい要素数（行数$\times$列数 $\gt$ ベクトル長）や小さい要素数（行数$\times$列数 $\lt$ ベクトル長）を指定するどどうなるでしょう？

#### 設問
以下のコードを実行して確認してください。
```{r matrix-over, exercise=TRUE, exercise.setup="matrix-ref-x"}
matrix(x, nrow = 3, ncol = 5)
matrix(x, nrow = 2, ncol = 2)
```
---

#### 解説
この動作はベクトル型のトピックで説明した不等長ベクトルの演算と同様に処理されます。元のベクトル長より大きな要素数を指定した場合には、不足分を元のベクトルの先頭から指定された要素数になるまで再利用します。
```{r}
matrix(x, nrow = 3, ncol = 5)
```
逆に要素数がベクトル長より少ない場合には指定要素数までを使い、残りを切捨てます。  
```{r}
matrix(x, nrow = 2, ncol = 2)
```
---


### 【演習】二次元参照 {.tabset}
マトリクス型の値を参照する場合もベクトル型と同様に`[]`演算子を用います。ベクトル型と異なるのは二次元で指定する点です。

#### 設問
以下のコードを実行して行を参照してください。
```{r matrix-ref-by-row, exercise=TRUE, exercise.cap="行参照", exercise.setup="matrix-ref-m"}
m[2, ]
```
以下のコードを実行して列を参照してください。
```{r matrix-ref-by-col, exercise=TRUE, exercise.cap="行参照", exercise.setup="matrix-ref-m"}
m[, 3]
```
以下のコードを実行して任意の要素を指定して参照してください。
```{r matrix-ref-by-pos, exercise=TRUE, exercise.cap="行参照", exercise.setup="matrix-ref-m"}
m[2, 3]
```
---

#### 解説
マトリクス型を表示した際に表示される`[row,]`と`[,col]`が位置を表していますので、参照する際にはこの表記を使います。表記が分からなくなった場合はマトリクス型を表示させてみてください。
```{r}
matrix(x, nrow = 3, ncol = 3)
```
---


### 【演習】一次元参照 {.tabset}
マトリクス型を参照する場合は二次元参照（`m[2, 3]`）が基本ですがベクトル型と同様に一次元参照（`m[n]`）も可能です。

#### 演習
$2$行$3$列のデータを一次元参照してください。
```{r matrix-ref-by-serise, exercise=TRUE, exercise.setup="matrix-ref-m"}

```

```{r matrix-ref-by-serise-hint, exercise=FALSE}
m[8]
```
---

#### 解説
```{r, include=FALSE}
m <- matrix(x, nrow = 3, ncol = 3)
```
マトリクス型はベクトル型に行列の情報が加わった型ですのでベクトル型と同様の参照もできます。
```{r}
str(m)
```
$2$行$3$列目は先頭から$8$番目の要素ですので、ベクトル型と同様に以下のように参照します。
```{r}
m
```
---

#### Tips
`byrow`オプションが有効になっている場合、指定位置によっては順番が異なることがありますので注意してください。
```{r}
n <- matrix(x, nrow = 3, ncol = 3)
n[1, 2]
n <- matrix(x, nrow = 3, ncol = 3, byrow = TRUE)
n[1, 2]
```
---



## データフレーム型
データフレーム型は分析において最も使われる型です。単にデータフレームとも呼ばれるこの型は複数のベクトル型をまとめて一つの変数として扱うことができます。なお、包含される全てのベクトル型は**等長**でなければなりません。  
例えばサンプルコードなどでよく使われる`iris`データセットはデータフレーム型です。データフレーム型はベクトル単位で様々な形式のデータ（整数・実数・文字など）を混在させることが可能です。
```{r}
iris
```

　  
データフレーム型を作成するには`data.frame`関数を使います。例えば整数、文字、論理型の三種類のベクトル型からなるデータフレーム型は以下のように指定します。
```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"), z = c(TRUE, FALSE, FALSE),
                 stringsAsFactors = FALSE)
df
```

```{r dataframe-ref-df, echo=FALSE}
df <- data.frame(x = 1:3, y = c("a", "b", "c"), z = c(TRUE, FALSE, FALSE),
                 stringsAsFactors = FALSE)
```



データフレーム型は包含するベクトル型全てが等長でなければなりませんが。不等長のデータを指定した場合はどうなるでしょうか？

### 【演習】不等長指定 {.tabset}

#### 設問
以下のコードを実行して不等長の指定をした場合、どのようになるか確認してください。
```{r dataframe-create, exercise=TRUE}
data.frame(x = 1:5, y = c("a", "b", "c"), z = c(TRUE, FALSE), 
           stringsAsFactors = FALSE)
```
---

#### 解説
ベクトル型と異なり自動的に補完されませんので、必ず等長で指定してください。

---

#### Tips
`data.frame`関数で指定している引数（`x`や`y`）は列名（変量名）として使われます。引数を省略した場合、以下のように値が列名（変量名）として使われますので可読性や処理性の観点から省略しないようにしてください。
```{r}
data.frame(x = 1:3, y = c("a", "b", "c"), c(TRUE, FALSE, FALSE),
           stringsAsFactors = FALSE)
```
---


### データフレーム型の参照
データフレーム型の参照方法には大きく二つの方法があります。

* `[]`演算子による参照
* `$`演算子による参照


### 【演習】`[]`演算子による参照 {.tabset}

#### 設問
`[]`演算子を使って2列目（変量`y`）の値を参照してください。
```{r dataframe-ref-by-extract, exercise=TRUE, exercise.setup="dataframe-ref-df"}

```

```{r dataframe-ref-by-extract-hint}
df[2, ]
```
---

#### 解説
データフレーム型はマトリクス型と同様に`[]`演算子による参照ができるようになっています。したがって、列参照や要素参照もマトリクス型と同様に可能です。
```{r}
df[, 2]
```
```{r}
df[2, 2]
```
---


### 【演習】`$`演算子による参照 {.tabset}

#### 設問
`$`演算子を使って1列目（変量`x`）を参照してください。
```{r dataframe-ref-by-dallor, exercise=TRUE, exercise.setup="dataframe-ref-df"}
df$x
```
---

#### 解説
列名（変量名）が設定されている場合、`$`演算子を利用して列名（変量名）で参照することができます。列名（変量名）で参照することによりコードの可読性などが確保されやすくなります。また、変量はベクトル型なので`[]`演算子による変量内の参照も可能です。
```{r}
df$x[2]
```
---


### マトリクス型とデータフレーム型の相互変換
マトリクス型とデータフレーム型の見た目の構造は似通っています。例えば列方向はどちらの型も必ず等長になっていますし、行方向はどちらの型も列数分だけあります。そこで、Rではマトリクス型とデータフレーム型が相互に変換できるように関数が準備されています。

　  

#### マトリクス型をデータフレーム型に
```{r}
as.data.frame(m)
```

　  

#### データフレーム型をマトリクス型に
```{r}
as.matrix(df)
```
マトリクス型が持てる値は全て同一の型でなければならないので複数の値の型をもつデータフレーム型をマトリクス型に変換した場合、強制的に型変換が行われ自動的に同一型になります。
```{r}
str(as.matrix(df))
```



## リスト型
データフレーム型は全ての列（変量）が等長でなければなりません。しかし、不等長のデータを一括して扱いたい場合もあります。そのような場合に便利なのがリスト型です。リスト型は関数の返り値とし使われることが多いので、すくなくとも値の参照方法を憶えてください。  
例えば、相関係数の検定（無相関の検定）を行う`cor.test`関数は検定結果を人が読んで分かりやすいようにコンソールへ出力してくれます。
```{r}
with(iris, cor.test(Petal.Length, Petal.Width))
```
しかし、検定結果の実体は下記のようなリスト型ですので、プログラムで結果を処理するにはリスト型の値を参照する方法を知っている必要があります。
```{r}
str(with(iris, cor.test(Petal.Length, Petal.Width)))
```

　  

### リスト型の作成 {.tabset}
リスト型を作成するには`list`関数を用いて、データフレーム型のように指定します。
```{r}
list(x = 1:5, y = c("a", "b")) 
```

```{r list-ref-l, echo=FALSE}
l <- list(x = 1:5, y = c("a", "b")) 
```

#### 設問
以下のコードを実行してリスト型を作成してください。
```{r list-create-l, exercise=TRUE}
l <- list(x = 1:5, y = c("a", "b")) 
l
```
---

#### 解説
リスト型は前述の通り不等長のベクトル型を複数包含することができます。
```{r}
str(l)
```
---

　  

### リスト型の参照
リスト型は要素名がついている場合、データフレーム型と同様に`$`演算子で参照することができます。
```{r}
l$x
l$x[3]
```

要素名がついていない場合は、`[[]]`演算子で参照します。
```{r}
l2 <- list(1:5, y = c("a", "b", "c")) 
l2[[1]]
l2[[1]][3]
```

　  
このようにリスト型を参照する方法は複数ありますので、目的に応じて適切な参照方法を選択してください。



## Lisence
[CC BY-NC-SA 4.0 <i class="fa fa-external-link"></i>](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja){target="_blank" title="ライセンスの要約"} , Sampo Suzuki

* 表示
    * あなたは 適切なクレジットを表示し、ライセンスへのリンクを提供し、変更があったらその旨を示さなければなりません。これらは合理的であればどのような方法で行っても構いませんが、許諾者があなたやあなたの利用行為を支持していると示唆するような方法は除きます。
* 非営利
    * あなたは営利目的でこの資料を利用してはなりません。
* 継承
    * もしあなたがこの資料をリミックスしたり、改変したり、加工した場合には、あなたはあなたの貢献部分を元の作品と同じライセンスの下に頒布しなければなりません。

　  

* 本資料中で引用してるロゴなどの著作権は原著作権者にあります。
